================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-21T13:35:07.098Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
category/
  infrastructure/
    CategoryMemoryRepo.go
cmd/
  main.go
internal/
  category/
    category.go
    repository.go
    service.go
  user/
    repository.go
    service.go
    user.go
user/
  infrastructure/
    UserMemoryRepo.go
go.mod
go.sum
README.md

================================================================
Repository Files
================================================================

================
File: category/infrastructure/CategoryMemoryRepo.go
================
package infrastructure

import (
	"errors"

	"github.com/google/uuid"
	"github.com/meez25/boilerplateForumDDD/internal/category"
)

var (
	ErrCategoryNotFound = errors.New("category not found")
)

type CategoryMemoryRepo struct {
	categories map[uuid.UUID]category.Category
}

func NewCategoryMemoryRepo() *CategoryMemoryRepo {
	return &CategoryMemoryRepo{
		categories: make(map[uuid.UUID]category.Category),
	}
}

func (r *CategoryMemoryRepo) Save(category category.Category) error {
	r.categories[category.ID] = category
	return nil
}

func (r *CategoryMemoryRepo) FindByID(ID string) (category.Category, error) {
	id, err := uuid.Parse(ID)
	if err != nil {
		return category.Category{}, err
	}

	cat, ok := r.categories[id]
	if !ok {
		return category.Category{}, ErrCategoryNotFound
	}

	return cat, nil
}

func (r *CategoryMemoryRepo) FindAll() ([]category.Category, error) {
	categories := make([]category.Category, 0, len(r.categories))
	for _, category := range r.categories {
		categories = append(categories, category)
	}
	return categories, nil
}

func (r *CategoryMemoryRepo) Update(category category.Category) error {
	r.categories[category.ID] = category
	return nil
}

func (r *CategoryMemoryRepo) Delete(ID string) error {
	id, err := uuid.Parse(ID)
	if err != nil {
		return err
	}

	delete(r.categories, id)
	return nil
}

================
File: cmd/main.go
================
package main

import (
	"fmt"

	// "github.com/meez25/boilerplateForumDDD/category/infrastructure"
	// "github.com/meez25/boilerplateForumDDD/internal/category"
	"github.com/meez25/boilerplateForumDDD/internal/user"
	"github.com/meez25/boilerplateForumDDD/user/infrastructure"
)

func main() {
	// This is the main function

	userRepo := infrastructure.NewUserMemoryRepository()
	userService := user.NewUserService(userRepo)

	// Create a new user
	newUser, err := user.NewUser("meez25", "yann@memofamille.com", "password", "Yann", "Meez")

	// Save the user
	err = userService.Register(newUser)

	if err != nil {
		panic(err)
	}

	fmt.Println("User created successfully")

	// Find the user by ID
	foundUser, err := userService.FindByID(newUser.ID.String())

	if err != nil {
		panic(err)
	}

	fmt.Println("User found by ID:", foundUser)

	// ----------------------------
	// Create a category

	// categoryRepo := infrastructure.NewCategoryMemoryRepo()
	// categoryService := category.NewCategoryService(categoryRepo)
	//
	// cat, err := categoryService.Create("Category 1", "Description 1", nil)
	//
	// if err != nil {
	// 	panic(err)
	// }
	//
	// fmt.Println("Category created successfully")
	//
	// // Find the category by ID
	//
	// foundCat, err := categoryService.FindByID(cat.ID.String())
	//
	// if err != nil {
	// 	panic(err)
	// }
	//
	// fmt.Println("Category found by ID:", foundCat)

}

================
File: internal/category/category.go
================
package category

import (
	"errors"
	"time"

	"github.com/google/uuid"
)

type Category struct {
	ID          uuid.UUID
	Title       string
	Description string
	ParentID    *uuid.UUID
	CreatedAt   time.Time
}

var (
	ErrEmptyTitle         = errors.New("title can't be empty")
	ErrorEmptyDescription = errors.New("description can't be empty")
)

func NewCategory(title, description string, parentID *uuid.UUID) (*Category, error) {
	if title == "" {
		return nil, ErrEmptyTitle
	}

	if description == "" {
		return nil, ErrorEmptyDescription
	}

	return &Category{
		ID:          uuid.New(),
		Title:       title,
		Description: description,
		ParentID:    parentID,
		CreatedAt:   time.Now(),
	}, nil
}

func (c *Category) Update(title, description string) error {
	if title == "" {
		return ErrEmptyTitle
	}

	if description == "" {
		return ErrorEmptyDescription
	}

	c.Title = title
	c.Description = description

	return nil
}

func (c *Category) SetParentID(parentID *uuid.UUID) {
	if parentID == nil {
		c.ParentID = nil
		return
	}

	c.ParentID = parentID
}

func (c *Category) GetParentID() *uuid.UUID {
	return c.ParentID
}

func (c *Category) GetID() uuid.UUID {
	return c.ID
}

func (c *Category) GetTitle() string {
	return c.Title
}

func (c *Category) GetDescription() string {
	return c.Description
}

func (c *Category) GetCreatedAt() time.Time {
	return c.CreatedAt
}

func (c *Category) IsRoot() bool {
	return c.ParentID == nil
}

func (c *Category) IsChild() bool {
	return c.ParentID != nil
}

================
File: internal/category/repository.go
================
package category

type CategoryRepository interface {
	Save(category Category) error
	FindByID(ID string) (Category, error)
	FindAll() ([]Category, error)
	Update(category Category) error
	Delete(ID string) error
}

================
File: internal/category/service.go
================
package category

import "github.com/google/uuid"

type CategoryService struct {
	repo CategoryRepository
}

func NewCategoryService(repo CategoryRepository) *CategoryService {
	return &CategoryService{
		repo: repo,
	}
}

func (s *CategoryService) Create(title, description string, parentID *string) (*Category, error) {
	var parentIDUUID *uuid.UUID

	if parentID != nil {
		id, err := uuid.Parse(*parentID)
		if err != nil {
			return nil, err
		}

		parentIDUUID = &id
	}

	newCategory, err := NewCategory(title, description, parentIDUUID)
	if err != nil {
		return nil, err
	}

	err = s.repo.Save(*newCategory)
	if err != nil {
		return nil, err
	}

	return newCategory, nil
}

func (s *CategoryService) FindByID(ID string) (*Category, error) {
	category, err := s.repo.FindByID(ID)
	if err != nil {
		return nil, err
	}

	return &category, nil
}

================
File: internal/user/repository.go
================
package user

type Repository interface {
	Save(user User) error
	FindByID(ID string) (User, error)
	FindByEmailAddress(email string) (User, error)
	FindByUsername(username string) (User, error)
	Update(user User) error
	Delete(ID string) error
}

================
File: internal/user/service.go
================
package user

type UserService struct {
	repo Repository
}

func NewUserService(repo Repository) *UserService {
	return &UserService{
		repo: repo,
	}
}

func (s *UserService) Create(username, email, password string, firstName string, lastName string) (User, error) {
	u, err := NewUser(username, email, password, firstName, lastName)

	if err != nil {
		return User{}, err
	}

	if err := s.Register(u); err != nil {
		return User{}, err
	}

	return u, nil
}

func (s *UserService) Register(u User) error {
	return s.repo.Save(u)
}

func (s *UserService) FindByID(ID string) (User, error) {
	return s.repo.FindByID(ID)
}

func (s *UserService) FindByEmailAddress(email string) (User, error) {
	return s.repo.FindByEmailAddress(email)
}

func (s *UserService) FindByUsername(username string) (User, error) {
	return s.repo.FindByUsername(username)
}

func (s *UserService) Update(u User) error {
	return s.repo.Update(u)
}

func (s *UserService) Delete(ID string) error {
	return s.repo.Delete(ID)
}

================
File: internal/user/user.go
================
package user

import (
	"errors"
	"time"

	"github.com/google/uuid"
)

type User struct {
	ID           uuid.UUID
	Username     string
	EmailAddress string
	Password     string
	FirstName    string
	LastName     string
	CreatedAt    time.Time
}

var (
	ErrEmptyUsername = errors.New("username can't be empty")
	ErrEmptyEmail    = errors.New("email can't be empty")
	ErrEmptyPassword = errors.New("password can't be empty")
)

func NewUser(username, email, password, firstName, lastName string) (User, error) {
	id, err := uuid.NewRandom()
	if err != nil {
		return User{}, err
	}

	if username == "" {
		return User{}, ErrEmptyUsername
	}

	if email == "" {
		return User{}, ErrEmptyEmail
	}

	if password == "" {
		return User{}, ErrEmptyPassword
	}

	return User{
		ID:           id,
		Username:     username,
		EmailAddress: email,
		Password:     password,
		FirstName:    firstName,
		LastName:     lastName,
		CreatedAt:    time.Now(),
	}, nil
}

================
File: user/infrastructure/UserMemoryRepo.go
================
package infrastructure

import (
	"errors"

	"github.com/google/uuid"
	"github.com/meez25/boilerplateForumDDD/internal/user"
)

type UserMemoryRepository struct {
	users map[uuid.UUID]user.User
}

var ErrUserNotFound = errors.New("user not found")

func NewUserMemoryRepository() *UserMemoryRepository {
	return &UserMemoryRepository{
		users: make(map[uuid.UUID]user.User),
	}
}

func (r *UserMemoryRepository) Save(u user.User) error {
	r.users[u.ID] = u
	return nil
}

func (r *UserMemoryRepository) FindByID(ID string) (user.User, error) {
	for _, u := range r.users {
		if u.ID.String() == ID {
			return u, nil
		}
	}
	return user.User{}, ErrUserNotFound
}

func (r *UserMemoryRepository) FindByEmailAddress(email string) (user.User, error) {
	for _, u := range r.users {
		if u.EmailAddress == email {
			return u, nil
		}
	}
	return user.User{}, ErrUserNotFound
}

func (r *UserMemoryRepository) FindByUsername(username string) (user.User, error) {
	for _, u := range r.users {
		if u.Username == username {
			return u, nil
		}
	}
	return user.User{}, ErrUserNotFound
}

func (r *UserMemoryRepository) Update(u user.User) error {
	r.users[u.ID] = u
	return nil
}

func (r *UserMemoryRepository) Delete(ID string) error {
	delete(r.users, uuid.MustParse(ID))
	return nil
}

================
File: go.mod
================
module github.com/meez25/boilerplateForumDDD

go 1.22.2

require github.com/google/uuid v1.6.0

================
File: go.sum
================
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=

================
File: README.md
================
# boilerplateForumDDD
